using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FinanceTracker.Generated.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace FinanceTracker.Generated.DependencyInjection;


[Generator]
public class ServiceInjectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var generationCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.ValidForGeneration);

        var compilationAndClasses = context.CompilationProvider.Combine(generationCandidates.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (spc, pair) =>
        {
            var (compilation, classModels) = pair;

            var serviceList = new List<string>();
            var validatorList = new List<string>();
            var namespaces = new HashSet<string>();

            foreach (var model in classModels.OrderBy(x => x.ServiceType))
            {
                if (string.Equals(model.ServiceCategory, "Service", StringComparison.OrdinalIgnoreCase))
                {
                    serviceList.Add($"services.TryAdd{model.DiscoveredAttribute}<{model.ServiceType}, {model.ClassName}>();");
                    if (!string.IsNullOrWhiteSpace(model.ClassNamespace)) namespaces.Add(model.ClassNamespace!);
                    if (!string.IsNullOrWhiteSpace(model.ServiceNamespace)) namespaces.Add(model.ServiceNamespace!);
                }
                else if (string.Equals(model.ServiceCategory, "Validator", StringComparison.OrdinalIgnoreCase))
                {
                    validatorList.Add($"services.TryAdd{model.DiscoveredAttribute}<{model.ServiceType}, {model.ClassName}>();");
                    if (!string.IsNullOrWhiteSpace(model.ClassNamespace)) namespaces.Add(model.ClassNamespace!);
                    if (!string.IsNullOrWhiteSpace(model.ServiceNamespace)) namespaces.Add(model.ServiceNamespace!);
                }
            }


            var serviceBody = new StringBuilder();
            foreach (var serviceModel in serviceList)
            {
                serviceBody.AppendLine(serviceModel);
            }
            
            var validatorBody = new StringBuilder();
            foreach (var validatorModel in validatorList)
            {
                validatorBody.AppendLine(validatorModel);
            }


            var usingBuilder = new StringBuilder();
            // Always include DI and extension usings
            usingBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            usingBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            // Include discovered namespaces
            foreach (var ns in namespaces.Distinct().OrderBy(s => s))
            {
                if (string.IsNullOrWhiteSpace(ns)) continue;
                if (ns == "Microsoft.Extensions.DependencyInjection" || ns == "Microsoft.Extensions.DependencyInjection.Extensions") continue;
                usingBuilder.AppendLine($"using {ns};");
            }
            // FluentValidation may be required for validator interfaces
            usingBuilder.AppendLine("using FluentValidation;");

            var codeToGenerate = $@"// <auto-generated/>
{usingBuilder}
namespace FinanceTracker
{{
    public partial class Program 
    {{
        public static void AddFinanceTrackerServices(IServiceCollection services)
        {{
            {serviceBody}
        }}

        public static void AddFinanceTrackerValidators(IServiceCollection services)
        {{
            {validatorBody}
        }}

    }}
}}";
            
            spc.AddSource("Program.g.cs", SourceText.From(codeToGenerate, Encoding.UTF8));
        });
        ;
    }

    private static (ClassDeclarationSyntax, bool ValidForGeneration, string? ClassName, string? DiscoveredAttribute, string? ServiceType, string?
        ServiceCategory, string? ClassNamespace, string? ServiceNamespace) GetClassDeclarationForSourceGen(
            GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) as INamedTypeSymbol;
        var className = classSymbol?.ToDisplayString() ?? classDeclarationSyntax.Identifier.Text;
        var classNamespace = classSymbol?.ContainingNamespace?.ToDisplayString();

        var hasServiceLevelAttribute = false;
        var serviceInterface = string.Empty;
        var hasCategoryAttribute = false;
        var category = string.Empty;
        var discoveredAttribute = string.Empty;
        string? serviceNamespace = null;


        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(attributeSyntax);
                if (symbolInfo.Symbol is not IMethodSymbol attributeCtor)
                    continue;

                var attributeType = attributeCtor.ContainingType;
                var attributeTypeName = attributeType.Name;

                if (!hasServiceLevelAttribute && (
                        attributeTypeName.StartsWith(SourceGeneratorConstants.ScopedAttributeName) ||
                        attributeTypeName.StartsWith(SourceGeneratorConstants.TransientAttributeName) ||
                        attributeTypeName.StartsWith(SourceGeneratorConstants.SingletonAttributeName)))
                {
                    hasServiceLevelAttribute = true;

                    if (attributeSyntax.Name is GenericNameSyntax gname && gname.TypeArgumentList.Arguments.Count > 0)
                    {
                        var ta = gname.TypeArgumentList.Arguments[0];
                        var tinfo = context.SemanticModel.GetTypeInfo(ta).Type;
                        serviceInterface = tinfo?.ToDisplayString() ?? ta.ToString();
                        serviceNamespace = tinfo?.ContainingNamespace?.ToDisplayString();
                    }
                    else
                    {
                        var typeArg = attributeType.TypeArguments.FirstOrDefault();
                        if (typeArg != null)
                        {
                            serviceInterface = typeArg.ToDisplayString();
                            serviceNamespace = typeArg.ContainingNamespace?.ToDisplayString();
                        }
                    }

                    if (attributeTypeName.StartsWith(SourceGeneratorConstants.ScopedAttributeName))
                        discoveredAttribute = SourceGeneratorConstants.ScopedAttributeName.Replace("Attribute", string.Empty);
                    else if (attributeTypeName.StartsWith(SourceGeneratorConstants.TransientAttributeName))
                        discoveredAttribute = SourceGeneratorConstants.TransientAttributeName.Replace("Attribute", string.Empty);
                    else if (attributeTypeName.StartsWith(SourceGeneratorConstants.SingletonAttributeName))
                        discoveredAttribute = SourceGeneratorConstants.SingletonAttributeName.Replace("Attribute", string.Empty);
                }

                if (!hasCategoryAttribute && attributeTypeName.StartsWith(SourceGeneratorConstants.InjectionCategoryAttributeName))
                {
                    hasCategoryAttribute = true;

                    var argExpr = attributeSyntax.ArgumentList?.Arguments.FirstOrDefault()?.Expression;
                    if (argExpr != null)
                    {
                        var txt = argExpr.ToString();
                        if (txt.Contains('.'))
                            category = txt.Split('.').Last();
                        else
                            category = txt;
                    }
                }
            }
        }

        if (hasServiceLevelAttribute && hasCategoryAttribute)
            return (classDeclarationSyntax, true, className, discoveredAttribute, serviceInterface, category, classNamespace, serviceNamespace);
        return (classDeclarationSyntax, false, null, null, null, null, null, null);
    }
}