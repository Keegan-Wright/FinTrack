using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FinanceTracker.Generated.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace FinanceTracker.Generated.DependencyInjection;


[Generator]
public class ServiceInjectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var generationCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.ValidForGeneration);

        var compilationAndClasses = context.CompilationProvider.Combine(generationCandidates.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (spc, pair) =>
        {
            var (compilation, classModels) = pair;

            var groupedModels = classModels.GroupBy(x => x.ServiceCategory).ToList();

            var serviceList = new List<string>();
            var validatorList = new List<string>();

            if (groupedModels.Any())
            {
                foreach (var groupedModel in groupedModels.First().OrderBy(x => x.ServiceType))
                {
                    serviceList.Add($"services.Add{groupedModel.DiscoveredAttribute}<{groupedModel.ServiceType}, {groupedModel.ClassName}>()");
                }
            
                foreach (var groupedModel in groupedModels.Last().OrderBy(x => x.ServiceType))
                {
                    validatorList.Add($"services.Add{groupedModel.DiscoveredAttribute}<{groupedModel.ServiceType}, {groupedModel.ClassName}>()");
                }
            }


            var serviceBody = new StringBuilder();
            foreach (var serviceModel in serviceList)
            {
                serviceBody.AppendLine(serviceModel);
            }
            
            var validatorBody = new StringBuilder();
            foreach (var validatorModel in validatorList)
            {
                validatorBody.AppendLine(validatorModel);
            }


            var codeToGenerate = $@"// <auto-generated/>

namespace FinanceTracker
{{
    public partial class Program 
    {{
        public static void AddFinanceTrackerServices(IServiceCollection services)
        {{
            {serviceBody}
        }}

        public static void AddFinanceTrackerValidators(IServiceCollection services)
        {{
            {validatorBody}
        }}

    }}
}}";
            
            spc.AddSource("Program.g.cs", SourceText.From(codeToGenerate, Encoding.UTF8));
        });
        ;
    }

    private static (ClassDeclarationSyntax, bool ValidForGeneration, string? ClassName, string? DiscoveredAttribute, string? ServiceType, string?
        ServiceCategory) GetClassDeclarationForSourceGen(
            GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var className = classDeclarationSyntax.Identifier.Text;

        
        var hasServiceLevelAttribute = false;
        var serviceInterface = string.Empty;
        var hasCategoryAttribute = false;
        var category = string.Empty;
        var disoveredAttribute = string.Empty;
        
        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            var validServiceAttributes = new List<string>()
            {
                $"{SourceGeneratorConstants.GeneratedNamespace}.{SourceGeneratorConstants.TransientAttributeName}",
                $"{SourceGeneratorConstants.GeneratedNamespace}.{SourceGeneratorConstants.ScopedAttributeName}",
                $"{SourceGeneratorConstants.GeneratedNamespace}.{SourceGeneratorConstants.SingletonAttributeName}",
            };


            if (validServiceAttributes.Contains(attributeName) && !hasServiceLevelAttribute)
            {
                hasServiceLevelAttribute = true;
                serviceInterface = attributeSymbol.TypeArguments.FirstOrDefault()?.ToDisplayString() ?? "NoService";
                disoveredAttribute = attributeName.Replace("Attribute", string.Empty);
            }


            if (attributeName ==
                $"{SourceGeneratorConstants.GeneratedNamespace}.{SourceGeneratorConstants.InjectionCategoryAttributeName}" &&
                !hasCategoryAttribute)
            {
                hasCategoryAttribute = true;
                category = attributeSymbol.Parameters.FirstOrDefault()?.ToDisplayString() ?? "No param";
            }

        }

        if (hasServiceLevelAttribute && hasCategoryAttribute)
            return (classDeclarationSyntax, true, className, disoveredAttribute, serviceInterface, category);

        return (classDeclarationSyntax, false, null, null, null, null);
    }
}